"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const filesystem_1 = require("./filesystem");
/**
 * Populates collections from disk.
 */
class CollectionPopulator {
    /**
     * Constructs new `CollectionPopulator` object.
     *
     * @param extensions Array of file extensions
     */
    constructor(extensions) {
        if (extensions.length === 0) {
            throw new Error('Array of supported extensions must not be empty');
        }
        this.extensions = extensions;
    }
    /**
     * Reads collections from path.
     *
     * @param path
     */
    readFromPath(path) {
        const subdirectories = filesystem_1.fileSystem.listValidDirectories(path);
        return this.readCollections(subdirectories, path);
    }
    /**
     * Read all collections from base path
     *
     * @param directories Array of directories names
     * @param inputDirectory Base directory
     */
    readCollections(directories, inputDirectory) {
        return directories.reduce((collections, directoryName) => {
            const relativePath = `${inputDirectory}/${directoryName}`;
            const collection = this.readCollection(relativePath, directoryName);
            if (collection) {
                collections.push(collection);
            }
            return collections;
        }, []);
    }
    /**
     * Reads collection along with documents content from a given path.
     *
     * @param path Collection Path
     * @param directoryName Directory name
     */
    readCollection(path, directoryName) {
        const name = this.getCollectionName(directoryName);
        const documents = this.populateDocumentsContent(path);
        if (!documents) {
            return null;
        }
        return {
            name,
            documents,
        };
    }
    /**
     * Populates MongoDB documents content by reading files.
     *
     * @param collectionPath Path for a single collection
     */
    populateDocumentsContent(collectionPath) {
        const fileNames = filesystem_1.fileSystem.listFileNames(collectionPath);
        if (fileNames.length === 0) {
            common_1.log(`Directory '${collectionPath}' is empty. Skipping...`);
            return;
        }
        const documentFileNames = filesystem_1.fileSystem.filterSupportedDocumentFileNames(fileNames, this.extensions);
        if (documentFileNames.length === 0) {
            common_1.log(`No supported files found in directory '${collectionPath}'. Skipping...`);
            return;
        }
        const documentPaths = documentFileNames.map(fileName => `${collectionPath}/${fileName}`);
        return filesystem_1.fileSystem.readFilesContent(documentPaths);
    }
    /**
     * Reads collection name from directory name.
     *
     * @param directoryName Directory name
     */
    getCollectionName(directoryName) {
        const separators = /\s*[-_\.\s]\s*/;
        const isMatch = directoryName.match(separators);
        if (!isMatch) {
            return directoryName;
        }
        const firstSeparator = isMatch[0];
        const splitArr = directoryName.split(firstSeparator);
        if (!this.isNumber(splitArr[0])) {
            return directoryName;
        }
        splitArr.shift();
        return splitArr.join(firstSeparator);
    }
    /**
     * Checks if a string is number.
     *
     * @param str String which can contain number
     */
    isNumber(str) {
        return /^\d+$/.test(str);
    }
}
exports.CollectionPopulator = CollectionPopulator;
//# sourceMappingURL=populator.js.map